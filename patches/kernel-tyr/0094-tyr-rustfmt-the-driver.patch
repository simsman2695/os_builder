From 0a57d1f5d019459f26ed58571b50daaf01dde4d7 Mon Sep 17 00:00:00 2001
From: Daniel Almeida <daniel.almeida@collabora.com>
Date: Tue, 8 Jul 2025 12:27:28 -0300
Subject: [PATCH 094/161] tyr: rustfmt the driver

The driver has files which are not properly formatted. Do it now, and
squash this commit later.
---
 drivers/gpu/drm/tyr/driver.rs   |  2 +-
 drivers/gpu/drm/tyr/fw.rs       | 11 +++---
 drivers/gpu/drm/tyr/fw/parse.rs | 61 +++++++--------------------------
 drivers/gpu/drm/tyr/sched.rs    |  6 +++-
 drivers/gpu/drm/tyr/wait.rs     | 10 +++---
 5 files changed, 28 insertions(+), 62 deletions(-)

diff --git a/drivers/gpu/drm/tyr/driver.rs b/drivers/gpu/drm/tyr/driver.rs
index 8cd71bf65f..3eda6013cd 100644
--- a/drivers/gpu/drm/tyr/driver.rs
+++ b/drivers/gpu/drm/tyr/driver.rs
@@ -47,10 +47,10 @@
 use crate::mmu;
 use crate::mmu::irq::MmuIrq;
 use crate::mmu::Mmu;
+use crate::new_wait;
 use crate::regs::*;
 use crate::sched::Scheduler;
 use crate::sched::SchedulerState;
-use crate::new_wait;
 use crate::wait::Wait;
 use crate::wait::WaitResult;
 
diff --git a/drivers/gpu/drm/tyr/fw.rs b/drivers/gpu/drm/tyr/fw.rs
index 29dcb2b52b..242f765514 100644
--- a/drivers/gpu/drm/tyr/fw.rs
+++ b/drivers/gpu/drm/tyr/fw.rs
@@ -232,11 +232,9 @@ pub(crate) fn init(
 
         let mut sections = Self::read_sections(tdev, iomem.clone(), gpu_info, vm.clone())?;
 
-        let shared_section = match sections.iter().position(|section| {
-                section.is_shared()
-        }) {
+        let shared_section = match sections.iter().position(|section| section.is_shared()) {
             Some(index) => sections.remove(index)?,
-            None        => {
+            None => {
                 dev_err!(tdev.as_ref(), "No shared section found in firmware");
                 return Err(EINVAL);
             }
@@ -389,8 +387,9 @@ impl<const N: usize> ModInfoBuilder<N> {
     ];
 
     /// Create the builder that generated the info at compile-time
-    pub (crate) const fn create(module_name: &'static kernel::str::CStr)
-        -> kernel::firmware::ModInfoBuilder<N> {
+    pub(crate) const fn create(
+        module_name: &'static kernel::str::CStr,
+    ) -> kernel::firmware::ModInfoBuilder<N> {
         let mut bld = kernel::firmware::ModInfoBuilder::new(module_name);
         // Walk over files listed above and add them to modinfo
         let mut i = 0;
diff --git a/drivers/gpu/drm/tyr/fw/parse.rs b/drivers/gpu/drm/tyr/fw/parse.rs
index 47c1f74e5c..10c9feded7 100644
--- a/drivers/gpu/drm/tyr/fw/parse.rs
+++ b/drivers/gpu/drm/tyr/fw/parse.rs
@@ -128,8 +128,7 @@ pub(crate) struct Section {
 
 impl Section {
     pub(super) fn is_shared(&self) -> bool {
-        self.va.start == CSF_MCU_SHARED_REGION_START
-            && self.flags.contains(flags::SHARED)
+        self.va.start == CSF_MCU_SHARED_REGION_START && self.flags.contains(flags::SHARED)
     }
 }
 
@@ -310,10 +309,7 @@ struct BinaryEntrySection {
 
 impl Firmware {
     /// Load the firmware
-    fn load(
-        tdev: &TyrDevice,
-        gpu_info: &GpuInfo,
-    ) -> Result<kernel::firmware::Firmware> {
+    fn load(tdev: &TyrDevice, gpu_info: &GpuInfo) -> Result<kernel::firmware::Firmware> {
         let gpu_id = GpuId::from(gpu_info.gpu_id);
 
         let fw_path = CString::try_from_fmt(fmt!(
@@ -348,11 +344,7 @@ pub(super) fn read_sections(
         let fw_bin_hdr = match BinaryHeader::new(tdev, &mut cursor) {
             Ok(fw_bin_hdr) => fw_bin_hdr,
             Err(e) => {
-                dev_err!(
-                    tdev.as_ref(),
-                    "Invalid firmware file: {}",
-                    e.to_errno()
-                );
+                dev_err!(tdev.as_ref(), "Invalid firmware file: {}", e.to_errno());
                 return Err(e);
             }
         };
@@ -365,13 +357,7 @@ pub(super) fn read_sections(
         let mut sections = KVec::new();
 
         while (cursor.pos() as u32) < fw_bin_hdr.size {
-            let section = Self::read_entry(
-                &mut cursor,
-                tdev,
-                iomem.clone(),
-                &fw,
-                vm.clone(),
-            )?;
+            let section = Self::read_entry(&mut cursor, tdev, iomem.clone(), &fw, vm.clone())?;
             if let Some(inner) = section.inner {
                 sections.push(inner, GFP_KERNEL)?;
             }
@@ -404,22 +390,14 @@ fn read_entry(
             return Err(EINVAL);
         }
 
-        let section_size =
-            section.hdr.size() as usize - size_of::<BinaryEntryHeader>();
+        let section_size = section.hdr.size() as usize - size_of::<BinaryEntryHeader>();
         let section = {
-            let mut entry_cursor =
-                cursor.view(cursor.pos()..cursor.pos() + section_size)?;
+            let mut entry_cursor = cursor.view(cursor.pos()..cursor.pos() + section_size)?;
 
             match section.hdr.entry_type() {
                 Ok(BinaryEntryType::Iface) => Ok(BinaryEntrySection {
                     hdr: section.hdr,
-                    inner: Self::read_section(
-                        tdev,
-                        iomem,
-                        &mut entry_cursor,
-                        fw,
-                        vm,
-                    )?,
+                    inner: Self::read_section(tdev, iomem, &mut entry_cursor, fw, vm)?,
                 }),
 
                 Ok(BinaryEntryType::BuildInfoMetadata) => {
@@ -445,20 +423,14 @@ fn read_entry(
                             dev_err!(
                                 tdev.as_ref(),
                                 "Failed to handle firmware entry type: {}\n",
-                                entry_type.map_or(
-                                    section.hdr.entry_type_raw(),
-                                    |e| e as u8
-                                )
+                                entry_type.map_or(section.hdr.entry_type_raw(), |e| e as u8)
                             );
                             Err(EINVAL)
                         } else {
                             dev_info!(
                                 tdev.as_ref(),
                                 "Unexpected firmware entry type: {}\n",
-                                entry_type.map_or(
-                                    section.hdr.entry_type_raw(),
-                                    |e| e as u8
-                                )
+                                entry_type.map_or(section.hdr.entry_type_raw(), |e| e as u8)
                             );
                             Ok(section)
                         }
@@ -507,9 +479,7 @@ fn read_section(
             return Ok(None);
         }
 
-        if hdr.va.start == CSF_MCU_SHARED_REGION_START
-            && !hdr.flags.contains(flags::SHARED)
-        {
+        if hdr.va.start == CSF_MCU_SHARED_REGION_START && !hdr.flags.contains(flags::SHARED) {
             dev_err!(
                 tdev.as_ref(),
                 "Interface at 0x{:x} must be shared",
@@ -597,8 +567,7 @@ fn read_build_info(
     ) -> Result<()> {
         let meta = BuildInfoHeader::new(tdev, cursor)?;
 
-        if meta.start() as usize > fw.size() || meta.end() as usize > fw.size()
-        {
+        if meta.start() as usize > fw.size() || meta.end() as usize > fw.size() {
             dev_err!(tdev.as_ref(), "Firmware build info corrupted\n");
             return Err(EINVAL);
         }
@@ -612,10 +581,7 @@ fn read_build_info(
 
         let index = meta.end() as usize - 1;
         if *fw.data().get(index).ok_or(EINVAL)? != b'\0' {
-            dev_warn!(
-                tdev.as_ref(),
-                "Firmware's git sha is not NULL terminated\n"
-            );
+            dev_warn!(tdev.as_ref(), "Firmware's git sha is not NULL terminated\n");
             return Err(EINVAL);
         }
 
@@ -623,8 +589,7 @@ fn read_build_info(
         dev_info!(
             tdev.as_ref(),
             "Firmware git sha: {}",
-            CStr::from_bytes_with_nul(fw.data().get(range).ok_or(EINVAL)?)
-                .unwrap_or(c_str!(""))
+            CStr::from_bytes_with_nul(fw.data().get(range).ok_or(EINVAL)?).unwrap_or(c_str!(""))
         );
 
         Ok(())
diff --git a/drivers/gpu/drm/tyr/sched.rs b/drivers/gpu/drm/tyr/sched.rs
index 43f8c724b0..da6d12e26c 100644
--- a/drivers/gpu/drm/tyr/sched.rs
+++ b/drivers/gpu/drm/tyr/sched.rs
@@ -345,7 +345,11 @@ fn program_cs_slot(
     }
 
     pub(crate) fn bind(&mut self, tdev: &TyrDevice, group: Arc<Group>) -> Result {
-        let csg_idx = self.csg_slots.iter().position(|slot| slot.is_none()).ok_or(EBUSY)?;
+        let csg_idx = self
+            .csg_slots
+            .iter()
+            .position(|slot| slot.is_none())
+            .ok_or(EBUSY)?;
         pr_warn!("Using csg slot {csg_idx}\n");
         self.bind_group(tdev, group, csg_idx)?;
         self.program_csg_slot(tdev, csg_idx, Priority::Low)
diff --git a/drivers/gpu/drm/tyr/wait.rs b/drivers/gpu/drm/tyr/wait.rs
index 3959926cb5..e20b74cb57 100644
--- a/drivers/gpu/drm/tyr/wait.rs
+++ b/drivers/gpu/drm/tyr/wait.rs
@@ -5,12 +5,12 @@
 use kernel::new_condvar;
 use kernel::new_mutex;
 use kernel::prelude::*;
+use kernel::sync::lock::mutex::MutexBackend;
+use kernel::sync::lock::Lock;
 use kernel::sync::Arc;
 use kernel::sync::CondVar;
 use kernel::sync::Mutex;
 use kernel::time::msecs_to_jiffies;
-use kernel::sync::lock::Lock;
-use kernel::sync::lock::mutex::MutexBackend;
 
 /// Creates a new `Wait<T>` instance with call-site-specific lockdep class key.
 ///
@@ -48,7 +48,7 @@ macro_rules! new_wait {
     ($data:expr, $name:literal) => {{
         let lock = new_mutex!($data, $name);
         $crate::wait::Wait::new_with_lock(lock)
-    }}
+    }};
 }
 
 pub(crate) use new_wait;
@@ -102,9 +102,7 @@ pub(crate) fn new_with_data(data: T) -> Result<Arc<Self>> {
     /// with provided Lock instance
     ///
     /// Use [`new_wait!`] instead.
-    pub(crate) fn new_with_lock(
-        lock: impl PinInit<Lock<T, MutexBackend>>
-    ) -> Result<Arc<Self>> {
+    pub(crate) fn new_with_lock(lock: impl PinInit<Lock<T, MutexBackend>>) -> Result<Arc<Self>> {
         Arc::pin_init(
             pin_init!(Self {
                 cond <- new_condvar!(),
-- 
2.51.0

