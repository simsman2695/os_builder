From ab5437692dbca24c4109b34739de1f69a33d665b Mon Sep 17 00:00:00 2001
From: Daniel Almeida <daniel.almeida@collabora.com>
Date: Fri, 24 Oct 2025 15:48:10 -0300
Subject: [PATCH 140/161] tyr: add custom mmap support

We need to do that in order to share the mmio region with userspace so
it can access the latest flush id. This is needed in order to run on top
of upstream mesa.
---
 drivers/gpu/drm/tyr/driver.rs |  23 ++++++--
 drivers/gpu/drm/tyr/mmap.rs   | 104 ++++++++++++++++++++++++++++++++++
 drivers/gpu/drm/tyr/regs.rs   |   2 +
 drivers/gpu/drm/tyr/tyr.rs    |   1 +
 4 files changed, 126 insertions(+), 4 deletions(-)
 create mode 100644 drivers/gpu/drm/tyr/mmap.rs

diff --git a/drivers/gpu/drm/tyr/driver.rs b/drivers/gpu/drm/tyr/driver.rs
index 8b1522be9c..37f47499fe 100644
--- a/drivers/gpu/drm/tyr/driver.rs
+++ b/drivers/gpu/drm/tyr/driver.rs
@@ -103,6 +103,9 @@ pub(crate) struct TyrData {
     /// The MMIO region.
     pub(crate) iomem: Arc<Devres<IoMem>>,
 
+    /// Physical address of the MMIO region.
+    pub(crate) mmio_phys_addr: u64,
+
     /// The firmware ping work.
     #[pin]
     pub(crate) ping_work: DelayedWork<Self, 0>,
@@ -252,10 +255,10 @@ fn probe(
         let mali_regulator = Regulator::<regulator::Enabled>::get(pdev.as_ref(), c_str!("mali"))?;
         let sram_regulator = Regulator::<regulator::Enabled>::get(pdev.as_ref(), c_str!("sram"))?;
 
-        let iomem = Arc::pin_init(
-            IoMem::new(pdev.io_request_by_index(0).ok_or(EINVAL)?),
-            GFP_KERNEL,
-        )?;
+        let io_resource = pdev.io_request_by_index(0).ok_or(EINVAL)?;
+        let mmio_phys_addr = io_resource.start();
+
+        let iomem = Arc::pin_init(IoMem::new(io_resource), GFP_KERNEL)?;
 
         issue_soft_reset(&iomem)?;
         gpu::l2_power_on(&iomem)?;
@@ -316,6 +319,7 @@ fn probe(
                 coherent: false, // TODO. The GPU is not IO coherent on rk3588, which is what I am testing on.
                 mmu,
                 iomem: i,
+                mmio_phys_addr,
                 ping_work <- new_delayed_work!("tyr-ping-work"),
                 sched <- new_mutex!(SchedulerState::Disabled),
                 tick_work <- new_work!("tyr_tick"),
@@ -432,6 +436,17 @@ impl drm::driver::Driver for TyrDriver {
         (PANTHOR_TILER_HEAP_CREATE, drm_panthor_tiler_heap_create, ioctl::RENDER_ALLOW, File::heap_create),
         (PANTHOR_TILER_HEAP_DESTROY, drm_panthor_tiler_heap_destroy, ioctl::RENDER_ALLOW, File::heap_destroy),
     }
+
+    fn mmap(
+        device: &TyrDevice,
+        file: &drm::File<File>,
+        vma: &kernel::mm::virt::VmaNew,
+    ) -> Option<Result>
+    where
+        Self: Sized,
+    {
+        crate::mmap::mmap(device, &*file.inner(), vma)
+    }
 }
 
 #[pin_data]
diff --git a/drivers/gpu/drm/tyr/mmap.rs b/drivers/gpu/drm/tyr/mmap.rs
new file mode 100644
index 0000000000..254b787d51
--- /dev/null
+++ b/drivers/gpu/drm/tyr/mmap.rs
@@ -0,0 +1,104 @@
+// SPDX-License-Identifier: GPL-2.0 or MIT
+
+use kernel::bindings;
+use kernel::error::code::*;
+use kernel::mm::virt::{flags as vma_flags, VmaNew};
+use kernel::page::{PAGE_SHIFT, PAGE_SIZE};
+use kernel::prelude::*;
+
+use crate::driver::TyrDevice;
+use crate::regs::CSF_GPU_LATEST_FLUSH_ID;
+
+const DRM_PANTHOR_USER_MMIO_OFFSET_64BIT: u64 = 1u64 << 56;
+const DRM_PANTHOR_USER_FLUSH_ID_MMIO_OFFSET: u64 = DRM_PANTHOR_USER_MMIO_OFFSET_64BIT;
+
+pub(crate) fn mmap(device: &TyrDevice, _file: &crate::file::File, vma: &VmaNew) -> Option<Result> {
+    let offset = (vma.pgoff() as u64) << PAGE_SHIFT;
+
+    if offset < DRM_PANTHOR_USER_MMIO_OFFSET_64BIT {
+        return None;
+    }
+
+    if offset != DRM_PANTHOR_USER_FLUSH_ID_MMIO_OFFSET {
+        return Some(Err(EINVAL));
+    }
+
+    if (vma.flags() & vma_flags::SHARED) == 0 {
+        return Some(Err(EINVAL));
+    }
+
+    if vma.end() - vma.start() != PAGE_SIZE {
+        return Some(Err(EINVAL));
+    }
+
+    if (vma.flags() & (vma_flags::WRITE | vma_flags::EXEC)) != 0 {
+        return Some(Err(EINVAL));
+    }
+
+    vma.try_clear_maywrite().ok();
+
+    vma.set_io();
+    vma.set_dontcopy();
+    vma.set_dontexpand();
+    vma.set_dontdump();
+
+    unsafe {
+        let vma_ptr = vma.as_ptr();
+        let mut flags = (*vma_ptr).__bindgen_anon_2.__vm_flags;
+        flags |= vma_flags::PFNMAP | vma_flags::NORESERVE;
+        (*vma_ptr).__bindgen_anon_2.__vm_flags = flags;
+
+        (*vma_ptr).vm_private_data = device as *const _ as *mut _;
+        (*vma_ptr).vm_ops = &VM_OPS as *const _ as *const _;
+    }
+
+    Some(Ok(()))
+}
+
+static VM_OPS: bindings::vm_operations_struct = bindings::vm_operations_struct {
+    open: None,
+    close: None,
+    may_split: None,
+    mremap: None,
+    mprotect: None,
+    fault: Some(vm_fault_handler),
+    huge_fault: None,
+    map_pages: None,
+    pagesize: None,
+    page_mkwrite: None,
+    pfn_mkwrite: None,
+    access: None,
+    name: None,
+    set_policy: None,
+    get_policy: None,
+    find_special_page: None,
+};
+
+unsafe extern "C" fn vm_fault_handler(vmf: *mut bindings::vm_fault) -> bindings::vm_fault_t {
+    const VM_FAULT_SIGBUS: bindings::vm_fault_t = 0x02;
+
+    let vma = unsafe { (*vmf).__bindgen_anon_1.vma };
+    let address = unsafe { (*vmf).__bindgen_anon_1.address };
+
+    let tdev_ptr = unsafe { (*vma).vm_private_data as *const TyrDevice };
+    if tdev_ptr.is_null() {
+        return VM_FAULT_SIGBUS;
+    }
+
+    let tdev = unsafe { &*tdev_ptr };
+
+    let offset = (unsafe { (*vma).vm_pgoff } << PAGE_SHIFT) as u64;
+
+    if offset != DRM_PANTHOR_USER_FLUSH_ID_MMIO_OFFSET {
+        return VM_FAULT_SIGBUS;
+    }
+
+    let phys_addr = tdev.mmio_phys_addr + CSF_GPU_LATEST_FLUSH_ID as u64;
+    let pfn = (phys_addr >> PAGE_SHIFT) as usize;
+
+    let pgprot = unsafe { (*vma).vm_page_prot };
+
+    let ret = unsafe { bindings::vmf_insert_pfn_prot(vma, address, pfn, pgprot) };
+
+    ret as bindings::vm_fault_t
+}
diff --git a/drivers/gpu/drm/tyr/regs.rs b/drivers/gpu/drm/tyr/regs.rs
index d48f0e0af5..223864f2e9 100644
--- a/drivers/gpu/drm/tyr/regs.rs
+++ b/drivers/gpu/drm/tyr/regs.rs
@@ -48,6 +48,8 @@ pub(crate) const fn l2_feature_line_size(l2_features: u32) -> u32 {
 pub(crate) const GPU_INT_RAWSTAT_DOORBELL_STATUS: u32 = bit_u32(18);
 pub(crate) const GPU_INT_RAWSTAT_MCU_STATUS: u32 = bit_u32(19);
 
+pub(crate) const CSF_GPU_LATEST_FLUSH_ID: usize = 0x10000;
+
 pub(crate) const GPU_INT_CLEAR: Register<0x24> = Register;
 pub(crate) const GPU_INT_MASK: Register<0x28> = Register;
 pub(crate) const GPU_INT_STAT: Register<0x2c> = Register;
diff --git a/drivers/gpu/drm/tyr/tyr.rs b/drivers/gpu/drm/tyr/tyr.rs
index 8aa2d20e9b..3f99865cad 100644
--- a/drivers/gpu/drm/tyr/tyr.rs
+++ b/drivers/gpu/drm/tyr/tyr.rs
@@ -42,6 +42,7 @@
 mod gem;
 mod gpu;
 mod heap;
+mod mmap;
 mod mmu;
 mod regs;
 mod sched;
-- 
2.51.0

