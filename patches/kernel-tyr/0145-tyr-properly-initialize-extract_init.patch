From 5389d55a1232a3e26a79cafceb40312de5d6b31d Mon Sep 17 00:00:00 2001
From: Daniel Almeida <daniel.almeida@collabora.com>
Date: Tue, 28 Oct 2025 16:34:09 -0300
Subject: [PATCH 145/161] tyr: properly initialize extract_init

---
 drivers/gpu/drm/tyr/sched.rs       | 9 +++++++--
 drivers/gpu/drm/tyr/sched/queue.rs | 4 ++++
 2 files changed, 11 insertions(+), 2 deletions(-)

diff --git a/drivers/gpu/drm/tyr/sched.rs b/drivers/gpu/drm/tyr/sched.rs
index 4a6c4b4f41..69946e89f2 100644
--- a/drivers/gpu/drm/tyr/sched.rs
+++ b/drivers/gpu/drm/tyr/sched.rs
@@ -319,7 +319,7 @@ pub(crate) fn program_csg_slot(
 
                 let csg_iface = glb_iface.csg_mut(csg_idx).ok_or(EINVAL)?;
 
-                for (cs_idx, queue) in inner.queues.iter().enumerate() {
+                for (cs_idx, queue) in inner.queues.iter_mut().enumerate() {
                     let cs_iface = csg_iface.cs_mut(cs_idx).ok_or(EINVAL)?;
 
                     self.program_cs_slot(queue, cs_iface)?;
@@ -369,10 +369,15 @@ pub(crate) fn program_csg_slot(
     ///
     /// Queues are alloted slots when their group is itself programmed into a
     /// CSG slot.
-    fn program_cs_slot(&mut self, queue: &Queue, cs_iface: &mut CommandStream) -> Result {
+    fn program_cs_slot(&mut self, queue: &mut Queue, cs_iface: &mut CommandStream) -> Result {
         let doorbell_id = queue.doorbell_id.ok_or(EINVAL)?;
         let mut cs_input = cs_iface.read_input()?;
 
+        let mut ringbuf_input = queue.interfaces.read_input()?;
+        let ringbuf_output = queue.interfaces.read_output()?;
+        ringbuf_input.extract_init = ringbuf_output.extract;
+        queue.interfaces.write_input(ringbuf_input);
+
         cs_input.ringbuf_base = queue.ringbuf.kernel_va().ok_or(EINVAL)?.start;
         cs_input.ringbuf_size = queue.ringbuf.size() as u32;
 
diff --git a/drivers/gpu/drm/tyr/sched/queue.rs b/drivers/gpu/drm/tyr/sched/queue.rs
index 589a91c4ed..80269e12c8 100644
--- a/drivers/gpu/drm/tyr/sched/queue.rs
+++ b/drivers/gpu/drm/tyr/sched/queue.rs
@@ -176,6 +176,10 @@ pub(crate) fn append_instrs(&mut self, instrs: &[u8]) -> Result {
         // Make sure that the ring buffer is updated before the INSERT register.
         kernel::sync::barrier::smp_wmb();
 
+        // We need to always save the latest extract point in case the CS is
+        // stopped and then resumed.
+        let ringbuf_output = self.interfaces.read_output()?;
+        ringbuf_input.extract_init = ringbuf_output.extract;
         ringbuf_input.insert += instrs.len() as u64;
 
         self.interfaces.write_input(ringbuf_input)?;
-- 
2.51.0

