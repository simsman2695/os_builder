From f3278d6ee2cb448d8abfe62ac7aaceab4560d4e6 Mon Sep 17 00:00:00 2001
From: Daniel Almeida <daniel.almeida@collabora.com>
Date: Wed, 25 Jun 2025 14:03:27 -0300
Subject: [PATCH 033/161] rust: gpuvm: add call to prepare

This call ensures that all objects within the VM have been locked. This is
needed during submits.

Note that this commit is not aimed at upstream, at least not for now. This
is because  this part of the GPUVM feature set will probably be handled
either by the new scheduler (being worked on by RedHat) or by a subsequent
patch once it becomes clear how it should be abstracted.

Signed-off-by: Daniel Almeida <daniel.almeida@collabora.com>
---
 rust/helpers/drm_gpuvm.c |  5 ++++
 rust/kernel/drm/gpuvm.rs | 54 ++++++++++++++++++++++++++++++++++++++++
 2 files changed, 59 insertions(+)

diff --git a/rust/helpers/drm_gpuvm.c b/rust/helpers/drm_gpuvm.c
index 6b0d0a6601..2a188919d5 100644
--- a/rust/helpers/drm_gpuvm.c
+++ b/rust/helpers/drm_gpuvm.c
@@ -16,3 +16,8 @@ struct drm_gpuvm_bo *rust_helper_drm_gpuvm_bo_get(struct drm_gpuvm_bo *vm_bo)
 {
 	return drm_gpuvm_bo_get(vm_bo);
 }
+
+void rust_helper_drm_gpuvm_exec_unlock(struct drm_gpuvm_exec *vm_exec)
+{
+	return drm_gpuvm_exec_unlock(vm_exec);
+}
diff --git a/rust/kernel/drm/gpuvm.rs b/rust/kernel/drm/gpuvm.rs
index cabba16074..4bdc15c83e 100644
--- a/rust/kernel/drm/gpuvm.rs
+++ b/rust/kernel/drm/gpuvm.rs
@@ -738,6 +738,12 @@ pub fn va_range(&self) -> Range<u64> {
         let end = start + self.va_length();
         Range { start, end }
     }
+
+    /// Prepares the objects within the VM, locking their reservations and
+    /// reserving `num_slots` for fences.
+    pub fn prepare(&self, num_slots: u32) -> Result<ExecToken<'_, T>> {
+        ExecToken::prepare(self, num_slots)
+    }
 }
 
 impl<T: DriverGpuVm> Deref for GpuVm<T> {
@@ -979,3 +985,51 @@ unsafe impl<T: DriverGpuVm> Send for GpuVmBo<T> {}
         Err(_) => core::ptr::null_mut(),
     }
 }
+
+use bindings::drm_gpuvm_exec;
+
+/// A token that ensures that all the objects within the VM are locked and that
+/// `num_slots` have been reserved for fences.
+pub struct ExecToken<'a, T: DriverGpuVm> {
+    _gpuvm: &'a GpuVm<T>,
+    vm_exec: Pin<KBox<bindings::drm_gpuvm_exec>>,
+    /// The number of slots reserved for fences.
+    pub num_slots: u32,
+}
+
+impl<'a, T: DriverGpuVm> ExecToken<'a, T> {
+    fn prepare(gpuvm: &'a GpuVm<T>, num_slots: u32) -> Result<Self> {
+        // We will probably replace this when the new scheduler debuts anyways,
+        // so just hack it for now.
+        const DRM_EXEC_INTERRUPTIBLE_WAIT: u32 = 0;
+        let mut guard = core::mem::ManuallyDrop::new(Self {
+            _gpuvm: gpuvm,
+            // vm_exec needs to be pinned, so stick it in a Box.
+            vm_exec: KBox::pin_init(
+                init!(drm_gpuvm_exec {
+                    vm: gpuvm.gpuvm.get(),
+                    flags: DRM_EXEC_INTERRUPTIBLE_WAIT,
+                    exec: Default::default(),
+                    extra: Default::default(),
+                    num_fences: num_slots,
+                }),
+                GFP_KERNEL,
+            )?,
+            num_slots,
+        });
+
+        // SAFETY: The object is valid and was initialized above
+        to_result(unsafe { bindings::drm_gpuvm_exec_lock(&mut *guard.vm_exec) })?;
+
+        Ok(core::mem::ManuallyDrop::into_inner(guard))
+    }
+}
+
+impl<'a, T: DriverGpuVm> Drop for ExecToken<'a, T> {
+    fn drop(&mut self) {
+        // SAFETY: We hold the lock, so it's safe to unlock.
+        unsafe {
+            bindings::drm_gpuvm_exec_unlock(&mut *self.vm_exec);
+        }
+    }
+}
-- 
2.51.0

